# 数对

## :question:题目描述
牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。牛牛希望你能帮他计算一共有多少个可能的数对。     
>输入描述:
输入包括两个正整数n,k(1 <= n <= 10^5, 0 <= k <= n - 1)。

>输出描述:
对于每个测试用例, 输出一个正整数表示可能的数对数量。

## :bulb:解决思路
条件：设x%y=m∈{0,1,2,...,y-1}，题意m≥k，所以y至少为k+1，否则余数都小于k    
方法：y的取值范围为k+1~n，遍历y，求出每一个y值对应的x个数相加得到结果    
思路：对于y来说，自然数1\~n除y的余数是0,1,2,3,...y-1,0,1,2,3,...y-1,...,n%y的这样的一个序列，余数按照0\~y-1的规律重复性地出现，其中0\~y-1完整重复地出现了n/y次，而余数0\~y-1中大于等于k的有y-1-k+1=y-k个，因此总共出现了(n/y)\*(y-k)次，最后还剩下0~n%y，如果n%y<k，那么都没有大于等于k的余数，结果就是(n/y)*(y-k)，如果n%y>=k，大于k的余数个数还要再加上(n%y-k+1)。    
**注意：当k=0时，余数队列第一个0对应的商为0，此时x为0不是正数，因此要减去1**

## :pencil2:代码
```c++
#include <iostream>

using namespace std;

int main(void) {
    int n, k, y;
    cin>>n>>k;
    //注意溢出
    long long count = 0;
    
    for(y = k+1; y <= n; y++){
        if(n%y < k)
            count += (n/y)*(y-k);
        else
            //当k为0时出现x=y*0+0=0，不为正整数，所以要-1
            count += (n/y)*(y-k)+(n%y-k+1)+(!k ? -1 : 0);
    }
    cout<<count;
    return 0;
}
```
[:arrow_left:上一题:迷路的牛牛](NiuniuIsLost.md)
[:arrow_right:下一题:矩形重叠](RectangleOverlap.md)